# LINQ

Inside our business logic, we can use LINQ to help us implement most of the logic.

There are two ways to write LINQ statements: using [Query syntax or using Method syntax](http://msdn.microsoft.com/en-us/library/bb397947.aspx):

```c#
  // Query syntax
  var result = from c in _courses.All()
  where c.Semester == "20143"
  orderby c.Name
  select c;
  
  // The same query, using Method syntax:
  var result = _courses.All().Where(c => c.Semester == "20143").OrderBy(c => c.Name);
```
Both queries are equivalent, and will result in identical queries being executed. There are however cases where it will
be more convenient to use one method over the other, so it is probably not a good idea to reject one or the other 
entirely.

## Materializing queries

A LINQ statement will usually result in a query object:

```c#
  var result = _courses.All().Where(c => c.Semester == "20143");
```
The result variable will now contain a query object. This object will however not be __materialized__ (i.e. the query
won't be executed), until the data is actually needed. There are several ways that could happen:

* Some code will try to enumerate the result, by calling foreach on the collection.
* The result is converted to a list, using result.ToList() or result.ToArray()
* We try to access a given value from the result, using First()/FirstOrDefault()/Single()/SingleOrDefault()
* We try to use some of the values in the result, by calling aggregate functions such as Count()/Min()/Max()/Average() etc.

This must be kept in mind at all times, since unneccesary materialization might result in a lot of data being
fetched needlessly.

## Join

We are going to need to join data from two or more tables in any moderately complex application. For instance,
assume we've got course instances in one table, and course templates in another. The name of each course would
be stored in the course template, since we would have data duplication if the name was stored for each
instance of a course. However, when getting a list of course instances (such as by semester), we
will probably need to include the name of each course instance, which requires a join:

```c#
  var result = from ci in _courseInstances.All()
               join ct in _courseTemplates.All() on ci.CourseID equals ct.ID
               where ci.Semester == "20143"
               select new 
               {
                  ID = ci.ID,
                  Name = ct.Name
                  // etc.
               };
```

This will result in an INNER JOIN query being executed, it will select all course instances for semester "20143"
(autumn 2014), and we will include the name of each course which we fetch from the course template.

Notice the use of the keyword __equals__ in the join statement.

If necessary, we can join more than two tables together in a given LINQ statement as well.

In some cases, we need other types of joins. Assume that a given course instance can have 0 or more teachers, and
that our data contains some courses with 0 teachers, some with 1 and some with more than one.
A regular join statement would simply skip those course instances with no teachers registered from
the result, and courses with more than one teacher could be repeated. What we would need in that case is a [left outer join](http://msdn.microsoft.com/en-us/library/bb397895.aspx). In this case, we use the __into__ keyword to select
all teachers into a collection which we can then manipulate further.
